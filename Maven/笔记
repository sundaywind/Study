1.Maven简介：项目管理工具；是apache下的一个开源项目，是纯Java开发，并且只是用来管理Java项目的（Maven仅仅适用于Java项目！）。

2.自动化构建和项目管理工具：
	Ant → Make → Maven → Gradle

3.Maven作用：
	①读音：妹文、麦文。
	②Maven作用一：自动化构建（项目构建）						    （清理）  （编译） （测试）（测试报告）   （打包）	       （部署）
		构建[build]：将我们开发的Java源码到把项目部署到服务器（tomcat、netty）上的过程。【clean → compile → test(testReport) → package(war、jar) → deploy】（将程序员编写的代码从源文件到服务器部署的整个过程）
		自动化构建：把构建整个过程，交给一个自动化工具完成。（将构建过程中的各个操作步骤交给构建工具自动完成）
	③Maven作用二：依赖管理[多了重复、少了报错]。
	④Maven作用三：项目信息管理。
	
4.Maven的安装：
	①要求当前系统环境下配置了JAVA_HOME（在CMD命令行中输入：echo %JAVA_HOME% 如果能出来JDK的安装目录，说明我们配置了JAVA环境）
	②将Maven的ZIP压缩包解压到一个非中文无空格目录下（剪切到安装目录）【maven.apache.org官方网站下载jar包（apache-maven-3.3.9-bin.zip）】
	③.配置环境变量，用mvn -v查看是否正确配置了maven【要配置jdk，  maven3.3.9这个版本所需的jdk版本必须要1.7以上】
		M2_HOME（或MAVEN_HOME）：F:\Wind\DevSoft\apache-maven-3.6.0
		path：D:\DevSoft\apache-maven-3.3.9\bin
		cmd命令行，用 mvn -v 查看maven版本。
			
5.Maven的优势： 
	1）统一的jar包管理（把所有项目所需的jar包放在同一地方），节省空间（将jar包放在Maven库中，使用的时候引用一下，不需要像以前一样 复制粘贴jar包到项目中的 /WEB-INF/lib目录下 节省空间）
	2）项目之间可以互相调用（依赖管理）。
	3）Maven还可以完成自动化构建。
	4）Maven是支持跨平台【Windows、Linux（稳定）】

6.Maven运行的命令：
	mvn clean --------------（清理）指的是将生成的target目录清理掉（编译后的.class文件）
	mvn compile ------------（编译）由java源码生成.class字节码文件
	mvn test ---------------（测试）执行src/test/java目录下的测试类的测试方法
	mvn package ------------（打包）将当前项目打成包【jar包、war包】
	mvn install ------------（安装）将当前项目生成的包【jar包、war包】放入到本地仓库中！
	
7.我们已经安装了Maven，运行时为什么还要下载？
	Maven主程序只是负责宏观调度，Maven具体命令的执行（做事的）所需依赖Maven的插件。
	
8.第一个Maven程序（我的电脑、cmd操作）：（Maven之所以能够实现“自动化”构建，就是因为它有一套“约定”的目录结构，源文件、二进制文件以及其他资源都有指定目录进行存储）
	1）首先建立Hello项目同时建立Maven约定的目录结构：
		Hello
		 --src
		 -----main
		 ---------java
		 ---------resources
		 -----test
		 ---------java
		 ---------resources
		 --pom.xml
	2）修改pom.xml文件：
		<?xml version="1.0" ?>
		<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
			<modelVersion>4.0.0</modelVersion>
			<groupId>com.offcn.maven</groupId>
			<artifactId>Hello</artifactId>
			<version>0.0.1-SNAPSHOT</version>
			<name>Hello</name>
			<dependencies>
				<dependency>
					<groupId>junit</groupId>
					<artifactId>junit</artifactId>
					<version>4.0</version>
					<scope>test</scope>
				</dependency>
			</dependencies>
		</project>
	3）在src/main/java/com/offcn/maven目录下新建文件Hello.java
		package com.offcn.maven;
		public class Hello {
			public String sayHello(String name){
				return "Hello "+name+"!";
			}
		}
	4）在/src/test/java/com/offcn/maven目录下新建测试文件HelloTest.java
		package com.offcn.maven;
		import org.junit.Test;
		import static junit.framework.Assert.*;
		public class HelloTest {
			@Test
			public void testHello(){
				Hello hello = new Hello();
				String results = hello.sayHello("litingwei");
				assertEquals("Hello litingwei!",results);		
			}
		}
	5）测试：
		①打开cmd命令行，进入Hello项目根目录（pom.xml文件所在目录）执行 mvn compile命令，查看根目录变化。
		②cmd 中继续录入mvn clean命令，然后再次查看根目录变化。
		③cmd 中继续录入 mvn clean compile命令，查看根目录变化。
		④cmd 中继续录入 mvn clean test命令，查看target目录变化。
		⑤cmd 中继续录入 mvn clean package命令，查看target目录变化。

9.Maven本地仓库:用来存放jar包或者插件：
	默认路径：C:\Users/当前用户/.m2/repository，通常本地仓库不会放在C盘。
	修改本地仓库的默认位置：Maven安装目录下 /conf/settings.xml
	修改： <localRepository>D:\repository\maven</localRepository>	
	
10.Maven仓库：[仓库里存放的是jar包或者插件]
	1）本地仓库：在当前计算机上，设置的文件夹。
	2）远程仓库：
		私服：公司内部大家一起使用的服务器。（本公司的）
		中央仓库：全世界都在使用的仓库，目前在美国。（https://mvnrepository.com/）
		中央仓库镜像：在全世界各个州，都存在一个仓库，内容和中央仓库中的内容一致，减小中央仓库的压力， 同时提升下载的速度。	
		阿里巴巴镜像：
		  <mirrors>
		    <mirror>
		      <id>alimaven</id>
		      <mirrorOf>central</mirrorOf>
		      <name>aliyun maven</name>
		      <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
		    </mirror>
		  </mirrors>

11.Maven必须熟知的概念：
	1）Project Object Model项目对象模型：
		①Maven将一个Java工程的相关信息封装后得到的对象。简称POM。
		②POM配置集中体现在pom.xml文件中，作为一个Maven工程，pom.xml是最核心的配置文件，作用相当于动态Web工程的web.xml。
	2）坐标：
			①数学坐标：平面中使用横纵两个坐标系可以唯一的定位平面中的任何一个点。
				向量x：横坐标
				向量y：纵坐标
			②使用三个向量在Maven仓库中唯一的定位一个Maven工程：（GAV）
				向量groupId：公司或组织的名称+项目名称	【<groupId>com.neuedu.maven</groupId>】
				向量artifactId：项目名称-模块名称		【<artifactId>Hello</artifactId>】
				向量version：模块版本					【<version>0.0.1-SNAPSHOT</version>】（快照版（开发）：SNAPSHOT；上线版（上线）：Release）
				packaging：定义该项目的打包方式 jar,war	【<packaging>maven-plugin</packaging>】
			③如何根据坐标找到仓库中查找对应的Maven工程：
				坐标：
					<groupId>org.springframework</groupId>
					<artifactId>spring-core</artifactId>
					<version>4.0.0.RELEASE</version>
				仓库中的路径：
					org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar
			④如何查找指定jar包的坐标：
				从Maven仓库下载：
					http://mvnrepository.com/【建议使用这个】
				    http://search.maven.org/
	3）Maven项目约定的目录结构：
		ProjectName
		   -src					【存放我们编写的源代码】
			   -main			【存放项目运行的源代码】
				   -java		【我们写java源码】		（存放项目的.java文件）
						-package【建包、建类】
				   -resources	【配置文件或者说资源文件】	（存放项目资源文件，如spring, hibernate配置文件）
			   -test			【存放的是我们写的测试代码】
				   -java		【测试源码】				（存放所有测试.java文件，如JUnit测试类）
						-package【建包、建类】
			       -resources	【测试代码需要的配置文件】	（测试资源文件）
			-target				【项目输出位置[编译后可以自动生成]】
			pom.xml				【Maven配置、依赖】
	4）依赖管理：Maven的依赖主要是指的jar包依赖。Maven依赖是靠pom.xml中dependencies/dependency标签来确定的！
	5）仓库管理
	6）Maven的生命周期：（Maven为了能够将构建过程自动化处理，定义了三个主要的生命周期。其中定义了相关的构建过程。）
		生命周期的每个命令在执行的时候都是从当前生命周期的最开始一个命令执行。【执行package，会从开始的clean、compile、package执行】（每个生命周期中执行任何一个操作，都是从这个生命周期最初的位置开始执行，直到到达命令指定的位）
		   1)clean生命周期【]清理周期】
				①pre-clean 	执行一些需要在clean之前完成的工作 
				②clean 		移除所有上一次构建生成的文件 
				③post-clean 执行一些需要在clean之后立刻完成的工作 
			  mvn clean
		   2)default生命周期【默认周期】
			  mvn compile：	编译:由java源码生成.class字节码文件
			  mvn test：		测试 :执行src/test/java目录下的测试类的测试方法
			  mvn package：	打包:将当前项目打成包【jar包、war包】
			  mvn install
		   3)site生命周期【站点周期】
				①pre-site：		执行一些需要在生成站点文档之前完成的工作
				②site：			生成项目的站点文档
				③post-site：	执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
				④site-deploy：	将生成的站点文档部署到特定的服务器上
		      mvn site
	7）插件和目标
	8）聚合和继承

12.第二个Maven工程（我的电脑、cmd操作）：
	1）新建第二个项目模块目录及约定的目录结构：
		HelloFriend
			 --src
			 -----main
			 ---------java
			 ---------resources
			 -----test
			 ---------java
			 ---------resources
			 --pom.xml
	2）在项目HelloFriend根目录修改pom.xml：
		<?xml version="1.0" ?>
		<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		  <modelVersion>4.0.0</modelVersion>
		  <groupId>com.offcn.maven</groupId>
		  <artifactId>HelloFriend</artifactId>
		  <version>0.0.1-SNAPSHOT</version>
		  <name>HelloFriend</name>
			<dependencies>
				<dependency>
					<groupId>junit</groupId>
					<artifactId>junit</artifactId>
					<version>4.0</version>
					<scope>test</scope>
				</dependency>		
				<dependency>
					<groupId>com.offcn.maven</groupId>
					<artifactId>Hello</artifactId>
					<version>0.0.1-SNAPSHOT</version>
					<scope>compile</scope>
				</dependency>
			</dependencies>
		</project>
	3）在src/main/java/com/offcn/maven目录下新建文件HelloFriend.java
		package com.offcn.maven;
		import com.offcn.maven.Hello;
		public class HelloFriend {
			public String sayHelloToFriend(String name){
				Hello hello = new Hello();
				String str = hello.sayHello(name)+" I am "+this.getMyName();
				System.out.println(str);
				return str;
			}
			public String getMyName(){
				return "John";
			}
		}
	4）在/src/test/java/com/offcn/maven目录下新建测试文件HelloFriendTest.java
	5）在HelloFriend目录下执行命令：mvn package
		系统报错说没有找到依赖（第一个Maven工程的jar包：没安装在本地仓库）。所有依赖的JAR包都应该正确安装到当前的Maven仓库中才能够使用，换句话说，Maven项目都是到当前仓库中去寻找它所依赖的JAR包的。
	6）需要重新构建Hello第一个项目并安装到数据仓库，在命令行Hello根目录下执行：mvn clean install
	7）重新在HelloFriend目录下执行命令：mvn package
	8）执行其他常用命令：site
		
13.Eclipse中整合Maven：
	1）打开Window --> Preferences --> Maven --> Installations（安装Maven）
	2）User Settings --> 找到自己安装目录下的 /conf/settings.xml --> 点击[Update Settings]
	
14.Maven项目创建：
	1）普通Java工程：
		（1）New Maven Project 	【Next】
		（2）选择quickstart 1.1	【Next】
		（3）填写GroupId、ArtifactId[项目名显示]、Version[保持默认]、Package[写Java代码的包名]。【Finish】
	2）动态Web工程（有web.xml文件的）：
		（1）New Maven Project 	【Next】
		（2）选择webapp 1.0		【Next】
		（3）填写GroupId、ArtifactId[项目名显示]、Version[保持默认]、Package[写Java代码的包名]。【Finish】
	3）正常情况下，以上两种都不会使用 少目录，创建的时候会勾选Create a simple project（第一个复选框）
		Maven的工程分类：
			jar工程：如果我们当前项目打成的包需要被别的项目依赖或者引用，就打成jar包。
			pom工程：父工程，聚合工程。
			war工程：如果当前项目需要部署到服务器上的时候，就打成war包！
				会报错，缺少web.xml文件：
					①手动添加；
					②自动生成：右键项目名 ---> Java EE Tools ---> Generate Deployment Descriptor Stub
		软件三层架构对应的Maven工程：
			Controller【war包】 ---> Service【jar包】 ---> Dao【jar包】
	
	
	
	
	
	
	
	
	
	
	
	
	
	

====================================================================================================================================================
====================================================================================================================================================
====================================================================================================================================================
 Maven的配置
	4.依赖管理
		①依赖复杂性
			[1]路径最短者优先   
					MakeFriends --------> HelloFriends----------->Hello
					                          |                    |
											 log4j.2.1.14         log4j.2.1.17		 
					
			[2]路径相同时，先声明者优先
					MakeFriends --------> HelloFriends ------>log4j.2.1.14
					      |
						  -------------->OurFriends   ------->log4j.2.1.12
						  
	
		②版本冲突的解决方案
			[1]调节原则：
				[1]路径最短者优先原则
				[2]路径相同时，先声明者优先原则
			[2]排除原则
				  	<dependency>
						<groupId>javax.servlet</groupId>
						<artifactId>servlet-api</artifactId>
						<version>2.5</version>
						<exclusions>
							<exclusion>
								<groupId></groupId>
								<artifactId></artifactId>
								<!--这里不需要指定版本号 -->
							</exclusion>
						</exclusions>
						<scope>provided</scope>
					</dependency>
			[3]版本锁定原则
				  <dependencyManagement>
					<dependencies>
						<dependency>
						   <!--jar包坐标 -->
							<groupId></groupId>
							<artifactId></artifactId>
							<version></version>
						</dependency>
					</dependencies>
				  </dependencyManagement>
				   
				   版本锁定之后，后面再使用到这个的 依赖的时候，就不要写版本号了！
				   而且如果有多个相同的需要锁定的jar包的版本号一致的话，我们可以单独提取到properties标签中，
				   在properties标签中，子标签自己定义，标签的值就是版本号，下面只需要在依赖的地方用${}引用就可以了！
				   
				
			
		③依赖方式
			[1]在pom.xml配置文件中使用dependencies/dependency元素配置依赖信息
			[2]通过目标jar包的坐标找到被依赖的文件
			
		④依赖范围
			默认compile：当前所依赖的jar包是当前Maven工程中所有类都需要使用的，最终也需要参与打包。
			test：只是当前工程中的测试类需要，最终不参与打包。
			provided：当工程在服务器上运行起来后，可以由服务器提供，所以也只是在开发或测试时使用，部署到服务器上时就不需要。
			……
		⑤一个自己开发的Maven工程，需要执行“安装”命令，才能够被放入到仓库中。


		
	5.项目信息管理
		将项目信息生成一个静态站点，用于展示。


		
						  


		
		
	7.关于Maven联网
		①联网下载内容：当前命令需要的Maven插件
		②Maven主程序仅负责宏观调度，并不能执行具体的命令。而具体的命令是通过Maven插件完成的。
		③Maven主程序会首先到本地仓库目录下查找需要的插件，若没有则联网从“中央仓库”下载。若当前环境不能联网则无法执行构建命令。
		④可以修改Maven默认的本地仓库路径，使其指向一个提前下载好的目录
			配置文件路径
				Maven解压目录/conf/settings.xml
			修改
				<localRepository>D:\Maven\Repository</localRepository>
				
					
				mvn -v 查看maven的版本号
				clean
					compile 编译
					test  测试
					package 打包(并将jar包放入到target的目录中)
					install 安装jar包到本地仓库中
					deploy
				
				site 生成一个站点
				
				clean 删除target目录
				
				
				
				自动创建目录的两种方式:
				 1.mvn archetype:generate 按照提示进行选择
				 2.mvn archetype:generate -DgroupId=组织名，公司网址的反写+项目名
										  -DartifactId=项目名-模块名
										  -Dversion=版本号
										  -Dpackage=代码所存在的包名
								  
	


		
	10.maven的几个概念：
	   1.坐标
			①数学坐标：平面中使用横纵两个坐标系可以唯一的定位平面中的任何一个点。
				向量x：横坐标
				向量y：纵坐标
				
			②使用三个向量在Maven仓库中唯一的定位一个Maven工程。
			
				向量groupid：公司或组织的名称+项目名称
				向量artifactId：项目名称-模块名称
				向量version：模块版本
				
				<groupId>com.neuedu.maven</groupId>
				<artifactId>Hello</artifactId>
				<version>0.0.1-SNAPSHOT</version>
				
			③如何根据坐标zhao到仓库中查找对应的Maven工程			
				坐标
					<groupId>org.springframework</groupId>
					<artifactId>spring-core</artifactId>
					<version>4.0.0.RELEASE</version>
				仓库中的路径
					org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar
					
			④如何查找指定jar包的坐标：
			     1.从maven仓库下载
				    http://search.maven.org/
					http://mvnrepository.com/【建议使用这个】
	
	11.依赖方式
		【1】在pom.xml配置文件中使用dependencies/dependency元素配置依赖信息
		【2】通过目标jar包的坐标做到被依赖的文件
		
	12.依赖的范围：
		
	   2.构件
构件的依赖范围。Maven在项目的构建过程中，会编译三套classpath，当我们需要引用某个类的时候，只需要将包含某个类的jar包加入到classpath中即可，maven在这里为我们提供了
三种classpath，分别对应：编译期，运行期，测试期。而依赖范围，就是为构件指定它可以作用于哪套classpath。

						  编译期           测试期            运行期            说明
compile                     √               √                 √                默认范围
provided                    √               √                               如jsp-api.jarservlet-api.jar,运行期由web容器提供
runtime                                     √                 √             	   
																	  编译期无需直接引用,只在测试和运行时有效，例如jdbc驱动类。
test                                        √                         只在测试的时候有效，如junit.jar
system                      √               √                                  与本地系统相关联，可移植性差。必须通过<systemPath></systemPath>元素，显示指定依赖文件的路径，如本机的JAVA_HOME路径，移植到其它机器就可能导致错误！
import                                                                         表示是继承父POM.XML中的依赖范围设置，只能使用在<dependencyManagement> 这个标签中。
		
		
		注意：依赖范围对依赖的传递是有影响的！
		
			
			
			
	第二个maven工程案例：
			
	注意：一个自己开发的maven工程，需要执行maven安装操作，才会将这个jar包放入到仓库的指定位置！
	
			
		 3.仓库
			①作用：保存Maven工程
			②分类
				[1]本地仓库：为当前电脑上所有Maven工程服务【本地仓库的配置只需要修改settings.xml文件就可以】
				[2]远程仓库[私服]：为当前局域网中的所有Maven工程服务器,公司维护
				[3]中央仓库：为全世界所有的Maven工程服务
				[4]中央仓库的镜像：内容和中央仓库一样，架设在全世界各个大洲，让Maven用户可以就近获取需要
						的Maven资源，同时也能够减轻中央仓库的压力。
						
				这几个仓库之间的关系
				
			③Maven工程分类
				[1]Maven用户自己开发的工程
				[2]Maven的插件
				[3]使用Maven构建得到的第三方jar包
		
	11.生命周期
			mvn clean
			mvn compile
			mvn test
			mvn package
			mvn install
		①Maven为了能够将构建过程自动化处理，定义了三个主要的生命周期。其中定义了相关的构建过程。
		②三个生命周期
			[1]清理周期
			[2]站点周期
			[3]默认周期
			
		③最重要的特点：每个生命周期中执行任何一个操作，都是从这个生命周期最初的位置开始执行，直到到达命令指定的位。

   

   12.Maven插件在eclipse中的设置
	13.创建第三个Maven项目【参考word文档】	
		
	14.继承
		①目的一：将pom.xml文件中重复的信息统一提取到父工程中，简化pom.xml中的配置
		②目的二：将各个子工程都需要依赖的jar包提取到父工程中统一管理
		③注意：父工程打包的方式——pom，表示这是一个管理其他工程的工程
			< packaging>pom</ packaging>
		④指定当前工程的父工程
			 <parent >
				   <groupId>com.atguigu.maven</groupId>
				  <artifactId>Parent</artifactId>
				  <version>0.0.1-SNAPSHOT</version>
				  
				   <!-- 如何通过当前工程的pom.xml文件找到父工程的pom.xml文件 -->
				   <!-- 配置父工程的pom.xml文件相对于当前工程pom.xml文件的相对路径 -->
				   <relativePath> ../Parent/pom.xml</relativePath >
			 </parent >
	 
	  在tomcat运行一遍，用插件运行一遍
	  
	 
	 
	 解决-Dmaven.multiModuleProjectDirectory system property is not set. Check $M2_HOME environment variable and mvn script match.
		1.添加M2_HOME的环境变量
	　　2.Preference->Java->Installed JREs->Edit 选择一个jdk,
	　　添加  -Dmaven.multiModuleProjectDirectory=$M2_HOME
	
	
	第四个Maven工程
	
	18.	处理编译版本
		在pom.xml中添加如下代码
			<build>
				<!-- 配置了很多插件JDK1.7 -->
				<plugins>
					<plugin>
						<groupId>org.apache.maven.plugins</groupId>
						<artifactId>maven-compiler-plugin</artifactId>
						<version>3.5.1</version>  
						<configuration>
							<source>1.7</source>
							<target>1.7</target>
							<encoding>UTF-8</encoding>
						</configuration>
					</plugin>
					<!-- tomcat7的插件-->
					<plugin>
						<groupId>org.apache.tomcat.maven</groupId>
						<artifactId>tomcat7-maven-plugin</artifactId>
						<version>2.2</version>
						<configuration>
							<path>/ssm</path>
							<port>8888</port>
						</configuration>
					  </plugin>
				</plugins>
			</build>
			
			<!--- 可以使用下面的这个插件启动本地的tomcat服务器 -->
				<plugin>
				  <groupId>org.codehaus.cargo</groupId>
				  <artifactId>cargo-maven2-plugin</artifactId>
				  <version>1.2.3</version>
				  <configuration>
					  <container>
						  <containerId>tomcat7x</containerId>
						  <home>D:\DevSoft\apache-tomcat-7.0.67</home>
					  </container>
					  <configuration>
						  <type>existing</type>
						  <home>D:\DevSoft\apache-tomcat-7.0.67</home>
						  如果Tomcat端口为默认值8080则不必设置该属性
						  <properties>
								<cargo.servlet.port>8080</cargo.servlet.port>
						  </properties>
					  </configuration>
				  </configuration>
				  <executions>  
					  <execution>  
						  <id>cargo-run</id>  
						  <phase>install</phase>  
						  <goals>  
							  <goal>run</goal>  
						  </goals>  
					  </execution>  
				  </executions>
			  </plugin>
			  
		添加jar包
			在pom中添加如下代码：

				<dependencies>
						<dependency>
							<groupId>junit</groupId>
							<artifactId>junit</artifactId>
							<version>4.9</version>
							<scope>test</scope>
						</dependency>
						<dependency>
							<groupId>javax.servlet</groupId>
							<artifactId>servlet-api</artifactId>
							<version>2.5</version>
							<scope>provided</scope>
						</dependency>
						<dependency>
							<groupId>javax.servlet</groupId>
							<artifactId>jsp-api</artifactId>
							<version>2.0</version>
							<scope>provided</scope>
						</dependency>
				</dependencies>
		
		
	
	15.聚合
		①目的：通过安装一个工程，将多个模块工程统一安装到仓库中
		②配置
			<modules>
				 <module >../Hello </module>
				 <module >../HelloFriend </module>
				 <module >../MakeFriends </module>
				 <module >../MavenWeb </module>
			</modules>

	16.实际作用
		①将一个项目拆分成多个子项目分别开发,并进行分布式部署
		②下载第三方jar包。

	17.Maven酷站
		①http://mavenrepository.com/
		搜索JAR包，下载JAR包，查询JAR包的坐标
		

		5.1添加依赖：
			打开maven仓库的视图、重建索引
					
		
		
		完整的项目构建过程包括：
			清理  编译  测试   打包  集成测试  验证 部署等步骤！
		
		
		
		
	
	19.pom.xml文件中的标签含义：
		<modelVersion>4.0.0</modelVersion>      ：Maven仓库中模型对象的版本号【实际是约束版本号】
	 
  	    <groupId>com.neuedu.ssm</groupId>
	    <artifactId>ssm-maven</artifactId>       #坐标【GAV】
	    <version>0.0.1-SNAPSHOT</version>        

		<packaging>war</packaging>               #打包方式：三种[Jar包，POM包，War包]
		
		<dependencies>
			<dependency>                         #Jar包的依赖，每个jar包所需要的GAV坐标
		<build>                                #build标签里面放的是插件
		  
		<plugins>                              #插件【复数】
		<plugin>                           该标签下是每个插件的坐标，每个插件还有各自的配置，配置写在Configuration标签中
		  
		
	20.将我们的SSM项目整合成maven项目并运行！
	
	
	21.将项目拆分成：分层拆分[项目]
		dao----->service------->web层
		
		
		注意：创建一个父工程【pom工程】,父工程不干事，只是管理子模块工程！
		      父工程里面可以放入一些jar包，而子工程继承父工程依赖的jar包【项目级别的继承】！
			  
	

	#################################################
	22.私服(Nexus)
	

5.maven的几个概念：
   1.坐标
   2.构件
   3.仓库
      1）本地仓库 
	  2）远程仓库 注意：如果在本地仓库中找不到我们所需要的构件，那么它会去全球的中央仓库去查找，找到之后就会下载到本地仓库中，供我们使用，如果远程仓库也找不到就会报错！
	  注意：中央仓库的位置可以在：maven安装目录下面的lib目录中的maven-model-builder-3.3.9.jar中找到，打开这个jar包\org\apache\maven\model\pom-4.0.0.xml文件中可以看到repositories标签
	        中的url中指定的值https://repo.maven.apache.org/maven2就是全球的中央仓库地址，中央仓库包含了绝大多数开源的java项目！
   
   4.镜像仓库（所谓镜像仓库，就是指A和B提供了一样的功能，maven的中央仓库都是位于国外的，有时因为一些原因导致我们可能无法访问外网，好在国内有它的镜像仓库,这样就可以直接访问国内的镜像仓库，速度也更快更稳定）
     注意:如何修改镜像仓库(也就是远程)的位置呢？
	      在maven的安装目录下的conf目录中有settings.xml这个文件，找到mirrors标签，然后将mirrors标签中的mirror实例拷贝出来，改成国内的镜像仓库，如下所示：
		       <mirror>
			      <id>nexus-aliyun</id>          #镜像仓库的id
			      <mirrorOf>*</mirrorOf>         #默认全球中央仓库的名字就是central
			      <name>Nexus aliyun</name>      #镜像仓库的名字
			      <url>http://maven.aliyun.com/nexus/content/groups/public</url>
			   </mirror>
			
		
         更改仓库位置：
            		本地仓库：默认是存放在c盘用户目录下的如：C:\Users\LIUHUI\.m2\repository
 					          但是我们一般不会将本地仓库放在C盘中，如果重装系统，那么仓库中的数据就会丢失了！所以我们可以
							  修改settings.xml文件修改里面的本地仓库<localRepository>D:/DevSoft/apache-maven-3.3.9/m2/repository</localRepository>
							  上面的<localRepository>/path</localRepository> 这里的/path要注意/哦，不是\哦！
							  
           	 
	    在eclipse 上安装maven;
		   注意：别忘了在配置jdk的地方加一个参数设置-Dmaven.multiModuleProjectDirectory=$M2_HOME
		
		
		   
		   
6.完整的项目构建过程包括：
  清理  编译  测试   打包  集成测试  验证 部署等步骤！
  
  maven中定义了3套相互独立的生命周期，分别包括：
	  clean 清理项目
	  default 构建项目
	  site 生成项目站点
	  
	  以上三套生命周期是相互独立的，每个生命周期又包含一些阶段，各个生命周期中 的阶段却是有顺序的，且后面的阶段依赖于前面的阶段，
	  执行某个阶段的时候其前面的阶段会依次顺序执行，但是不会触发另外两套生命周期的任何阶段！
	  
  
  举例：
    maven生命周期：
    clean 、compile、test、package、install
	也就是说运行这里面的任何一个命令，那么此命令之前的命令都会依次执行！
	
	
	clean清理项目，clean又分为3个阶段
	   pre-clean 执行清理前的工作
	   clean 清理上一次构建生成的所有文件
	   post-clean 执行清理后的文件
	   
	  
	default:是生命周期中最核心的，主要用于构建项目，default又分为如下阶段：
	   compile、test、package、install
	   
	site:生成项目站点,主要包含以下几个阶段：
	   pre-site 在生成项目站点前要完成的工作
	   site 生成项目的站点文档
	   post-site 在生成项目站点要完成的工作
	   site-deploy 发布生成的站点到服务器上
	   
	  
    	  
    	
	maven的source插件可以将当前项目的源码打成jar包，然后将source插件绑定到default周期的package阶段，也就是说在package这个阶段运行source这个插件，如下配置pom.xml文件,
	它有5个运行目标，我们这里设置运行目标为：jar-no-fork,如下配置！
	 
    <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-source-plugin</artifactId>
				<version>2.4</version>
				<executions>
					<execution>
						<phase>package</phase>
							<goals>
								 <goal>jar-no-fork</goal>
							</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
    </build>
	


	
	
7. pom.xml常用元素介绍：
     pom是maven项目的核心管理文件，用于项目项目描述，组织管理，依赖管理和构建信息的管理，pom中标注了许多的标签，这里我们介绍几个：
     <project>标签是pom.xml文件的根元素，它包含pom.xml的一些约束信息。
	 <modelVersion>是一个固定的版本，也是一个必须的元素，它的值为4.0.0,它指定了当前pom的版本
	 紧接着就是坐标信息：由<groupId> 、<artifactId>、<version>、<packaging>这几部分组成,其中
	 <groupId> 是主项目的标识，用于标识我们的maven项目是属于哪个实际项目的，格式：<groupId>反写的公司网址+项目名</groupId>
			  这里有一点要注意；maven的项目和我们实际的项目不是一个概念，maven的项目体现的是一个个模块化的概念，因此一个实际项目实际上会被
			  划分为很多的模块！
	  <artifactId>是一个模块的标识,是实际项目中的一个模块，格式：<artifactId>项目名+模块名</artifactId>
	  <version>标识当前项目的版本号，版本号一般都是由3个数字来组成的，第一个0表示大版本号，第二个0表示分支版本号，第3个0表示小版本号，eg:0.0.1snapshot除了这种
	            snapshot快照版本，
				一般还有alpha版本，也就是内测的测试版本，一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.
				再就是Beta版本，就是公测版，这个阶段的版本会一直加入新的功能。
				还有就是release版本，release版本是一个稳定版本，
				最后一个是GA版本，GA版本是正式的发布版本！
	             
	  <packaging>:表示maven打包的方式，不指定的话maven默认的是jar包；当然还可以打成war包，zip包，pom包等等！
	 
	  
	  <name> :name标签一般是项目的描述名，一般是产生项目文档的时候才会使用
	  <url> ：url是项目的地址
	  <description>：description是项目的描述
	  <developers> :developers表示开发人员的列表；当项目发布的时候，可以将我们开发人员的信息填写上去！
	  <licenses>:licenses表示许可证的信息，比如我们经常用到的一些开源框架，它都会有些许可证信息
	  <organization>: organization表示的是组织的信息
	  
	  
	  <dependencies>:依赖列表，它底下可以包含多个依赖项<dependency>，依赖项中如何确定一个依赖所在的位置呢，我们需要指定它的坐标，也就是
	                 <groupId>、<artifactId>、<version>当然还可以指定<type>、<scope>，这个scope指的是一个依赖的范围，我们之前的junit写的依赖的
					 范围是test，这个test表示junit构建，也就是这个jar在我们的测试依赖范围内有用!比如在我们的主代码中引用这个junit类的话就会报错！
					 在依赖项中还有<optional>标签，这个标签只有两个值，true或者false,它的意思是用来设置依赖是否可选，默认是false,子项目
					 如果默认是false的话，子项目默认是继承的，如果是true，那么子项目必须显示的引入改依赖！
					 <dependency>依赖项中还有一个<exclusions>列表，它表示排除依赖的传递列表，这个标签下面可以排除多个依赖<exclusion>，这有什么用呢？
					 比如Ajar包依赖B，而Bjar包又依赖于Cjar包，那么C对于A来说就是传递依赖，如果A不想依赖于C就可以使用这个<exclusion>标签！
					 
					 
	  <dependencyManagement> 
		 <dependencies>
		 </dependencies>
	  </dependencyManagement>
	  
	  注意： 上面这个<dependencyManagement> 标签是依赖管理，在里面我们也可以声明依赖的列表，然后里面包含多个依赖，但是呢，它并不会引用到实际的依赖中！
	          这个<dependencyManagement> 标签主要定义在父模块中，供子模块继承用的，比如我们的多个maven项目中都用到了junit,那么我们就可以抽象出来
			  一个父类的模块，然后再父类模块中对junit进行定义，其它子模块直接继承它（父模块）就可以了
	
      <build>：这个build通常为我们构建的行为提供相应的支持！这个build标签里面经常用到的标签是plugins插件标签如下所示：
	  <build>
	     <!--插件列表--> 在这个plugins插件列表中可以包含多个<plugin>标签，也就是可以有多个plugin插件，我们之前使用到了打包的source插件，在plugin中我们依旧要指出插件的坐标<groupId> <artifactId> <version>！
		<plugins>
			<plugin>
			</plugin>
		</plugins>
	  </build>
	  
	  
	  <parent> ：这个标签通常在子模块中用于对父模块的POM的一个继承！
	  <modules>: 这个标签是用来聚合运行多个的maven项目，如果有很多的maven模块需要编译的话，我们之前的办法是一个一个的编译，使用了这个标签，我们就可以在这里
	             定义多个的<module>模块，然后可以放在一起编译
	  
   
   

    例子1：此pom工程依赖于hadoop-demo02，而hadoop-demo02又依赖于hadoop-demo01，但是在这个工程中如果不想依赖于hadoop-demo01那么可以如下所示使用<exclusions>标签将其排除，但是这里要注意：排除的时候在<exclusion>标签中只有<groupId>、<artifactId>这两个标签，并没有<version>标签！
	    <dependency>
		  <groupId>com.bawie.hadoop</groupId>
		  <artifactId>hadoop-demo02</artifactId>
		  <version>0.0.1-SNAPSHOT</version>
		  <exclusions>
			<exclusion>
			  <groupId>com.bawie.hadoop</groupId>
			  <artifactId>hadoop-demo01</artifactId>
			</exclusion>
		  </exclusions>
		</dependency>

    除此之外，我们在clipse中创建maven项目的时候，会显示jdk的版本是J2SE-1.5但是我们看的时候又发现实际上我们使用的是我们自己安装的1.7的jdk版本，这是因为maven默认使用的就是jdk1.5版本的，
	这时候我们可以右键单击JRE Sysstem Library[J2SE-1.5]，在弹出的properties属性中修改为1.7。但是这么修改起来比较麻烦，每次创建一个项目都需要这样修改一遍，那么有没有一劳永逸的方法呢？
	我们可以打开我们的maven的配置文件settings.xml文件,找到profiles标签，加入如下代码即可！
	
	   <profile>
		 <id>jdk-1.7</id>
		 <activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.7</jdk>                                           #指定jdk的版本为1.7,
		 </activation>
		 <properties>
			<maven.compiler.source>1.7</maven.compiler.source>
			<maven.compiler.target>1.7</maven.compiler.target>
			<maven.compiler.compilerVersion>1.7</maven.compiler.compilerVersion>
		 </properties>
	   </profile>
	   
	   这里配置好了，重启eclipse,再次创建maven项目的时候就是显示jdk1.7了，这是全局的设置，如果这种方式不是很奏效，那么也可以设置局部的，如下所示：在自己项目的pom.xml文件中做如下设置！
		  <build>
		   <plugins>
			 <plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>	
				</configuration>
			  </plugin>
			</plugins>
		   </build>

		  设置好了之后更新一下项目就好了！
		  
















		  
		编译期：       测试期：       运行期：            说明：
compile       √         √         √         默认范围
provided      √         √                   如jsp-api.jarservlet-api.jar,运行期由web容器提供。
runtime                 √         √         编译期无需直接引用,只在测试和运行时有效，例如jdbc驱动类。
test                              √         只在测试的时候有效，如junit.jar。
system        √         √                   与本地系统相关联，可移植性差。必须通过<systemPath></systemPath>元素，显示指定依赖文件的路径，如本机的JAVA_HOME路径，移植到其它机器就可能导致错误！
import                                      表示是继承父POM.XML中的依赖范围设置，只能使用在<dependencyManagement> 这个标签中。		  
==========================================工作了不用我们管这些jar包的pom文件===============================
如果一定要查：可以在百度上直接搜索：ssm pom.xml直接改改版本号就可以了！
	http://doc.okbase.net/Naploen8/archive/124775.html
	


				  
							  
	
注意：
   maven构件定义
　　构件：在Maven中，任何依赖(jar包,tomcat等)，或项目(自己打包的jar,war等)输出都可成为构件。每个构件都有自己的唯一标识(唯一坐标)，由groupId，artifactId，和version等信息构成，
          由此，Maven就可以对构件进行版本控制，管理。
		  
		groupId：当前Maven构件隶属的项目名。实际开发中，项目往往会模块化开发，如spring-core,spring-aop等，他们都是Spring项目下不同的模块。命名方式与Java包名类似，通常是域名的反向书写。如ch.qos.logback，事实上项目管理组织的网址是：http://logback.qos.ch/ 。(必须)
		artifactId：隶属项目中的模块名（通常为项目名-模块名的方式书写）。(必须)
		version：当前版本。(必须)
		packaging：打包方式，如jar,war... (必须)
		classifier：帮助定义构建输出的一些附属构件。如spring-core.jar，还生成有文档javadoc.jar，源码sources.jar。
	
	构件特性
		1.构件（依赖）具有依赖传递。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。
		2.构件之间存在版本冲突时，Maven会依据 “短路优先” 原则加载构件。此外，我们也可以在POM.XML中，使用<exclusions></exclusions>显式排除某个版本的依赖，以确保项目能够运行。
			1)项目依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。
			2)项目依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.0.0)。
			
			总结：依赖冲突的意思就是说：如果有A和B依赖了一个不同版本的相同构件，那么对于C来说，它到底是依赖的A里面的构件还是B里面的构件！
			      这里有两条原则：第一，短路优先（优先解析路径短的版本），第二：如果路径长度相同，则谁先声明,谁优先！
		3.构件的依赖范围。Maven在项目的构建过程中，会编译三套classpath，当我们需要引用某个类的时候，只需要将包含某个类的jar包加入到classpath中即可，maven在这里为我们提供了
		                  三种classpath，分别对应：编译期，运行期，测试期。而依赖范围，就是为构件指定它可以作用于哪套classpath。

			编译期：       测试期：       运行期：            说明：
compile       √         √         √         默认范围
provided      √         √                   如jsp-api.jarservlet-api.jar,运行期由web容器提供。
runtime                 √         √         编译期无需直接引用,只在测试和运行时有效，例如jdbc驱动类。
test                              √         只在测试的时候有效，如junit.jar。
system        √         √                   与本地系统相关联，可移植性差。必须通过<systemPath></systemPath>元素，显示指定依赖文件的路径，如本机的JAVA_HOME路径，移植到其它机器就可能导致错误！
import                                      表示是继承父POM.XML中的依赖范围设置，只能使用在<dependencyManagement> 这个标签中。
	
			
			
			
		4.聚合
			如果在maven中我们想将多个项目进行install，将其安装到本地仓库中，必须对其依次执行install命令，maven中有一种方式，可以将其放到一起运行，
			这种方式称之为聚合，这里我们将之前的maven项目，进行聚合，只需要在创建maven项目（此项目作为其它POM的容器）的时候，将pom.xml文件的<packaging>标签修改为pom,不再是jar或者war包了
			然后使用<modules>标签，在<modules>标签中用<module>标签来找到我们要聚合的项目，如下所示：
			
			  <groupId>com.bawie.hadoop</groupId>
			  <artifactId>hadoop-demo03</artifactId>
			  <version>0.0.1-SNAPSHOT</version>
			  <packaging>pom</packaging>

			  <name>hadoop-demo03</name>
			  <url>http://maven.apache.org</url>

			  <properties>
				<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
			  </properties>

			 <modules>
				<module>../hadoop-demo01</module>
				<module>../hadoop-demo02</module>
				<module>../hadoop-demo03</module>
			 </modules>
						
			  <dependencies>
				<dependency>
				  <groupId>junit</groupId>
				  <artifactId>junit</artifactId>
				  <version>3.8.1</version>
				  <scope>test</scope>
				</dependency>
			  </dependencies>		
			
			这样就可以对所有的项目进行全局的控制了！
			
			
			
		5.继承
			在上面的每个demo中无论是jar包的hadoop-demo01、hadoop-demo02、hadoop-demo03以及还是打成pom包的hadoop-demo05我们都用到了junit的，都对其进行了配置
			那么这就有很多重复的地方，其实在maven中也可以像在java中一样，将其共同的组件配置到一个父工程中，此时我们就可以创建一个parent父maven工程。
			然后将<dependencies>标签放入到<dependencyManagement>标签中，在<dependencyManagement>标签中的依赖并不会在本项目中运行，同时也可以将junit依赖的版本号
			提取出来，在上面的<properties>的属性中，在这里自定义一个版本号的标签并写入版本号，在下面依赖的地方只需要用类似于EL表达式的方式来调用它即可，并将
			本项目的 <packaging>修改为pom,其实对于parent父maven工程而言，src下面的test目录和main目录是没有任何作用的,将这两个目录删除之后更新一下maven 项目就好，如下所示：
			  
			  <groupId>com.bawie.hadoop</groupId>
			  <artifactId>hadoop-parent</artifactId>
			  <version>0.0.1-SNAPSHOT</version>
			  <packaging>pom</packaging>

			  <name>hadoop-parent</name>
			  <url>http://maven.apache.org</url>

			  <properties>
				<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
				<junit.version>3.8.1</junit.version>
			  </properties>

			<dependencyManagement>
			  <dependencies>
				<dependency>
				  <groupId>junit</groupId>
				  <artifactId>junit</artifactId>
				  <version>${junit.version}</version>
				  <scope>test</scope>
				</dependency>
			  </dependencies>
			</dependencyManagement>
			
			
			
		在子项目中就可以使用<parent>标签引入父POM的坐标，并删除junit的版本号和scope，这样junit就从父POM中继承过来了，如下所示：
		  <groupId>com.bawie.hadoop</groupId>
		  <artifactId>hadoop-demo01</artifactId>
		  <version>0.0.1-SNAPSHOT</version>
		  <packaging>jar</packaging>

		  <name>hadoop-demo01</name>
		  <url>http://maven.apache.org</url>

		  <properties>
			<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		  </properties>

		  <parent>
			  <groupId>com.bawie.hadoop</groupId>
			  <artifactId>hadoop-parent</artifactId>
			  <version>0.0.1-SNAPSHOT</version>
		  </parent>
		  <dependencies>
			<dependency>
			 <groupId>junit</groupId>
			 <artifactId>junit</artifactId>
			</dependency>
		  </dependencies>
		  
		
8.在maven中如果创建web项目：
	在创建maven项目的时候要选择webapp的archetype插件！
	创建好了maven项目之后，补齐没有创建的maven的目录 比如：src/main/java、src/main/resources、src/test/java、src/test/resources目录，
	然后选择本项目右击properties属性，在弹出的框中选择Deployment Assembly然后将test目录下东东都删除，方式测试目录下的东西发布到服务器上，
	然后选择project facets在弹出来的对话框中选择Dynamic Web Module模块，这样就是一个web项目了，当然也可以在后面的runtime选择我们自己安装的tomcat,也可不选（不选就手动加入或者用插件）！
			
			
			
			

			
			
9.Maven
	1、依赖管理、jar包、工程之间的依赖。
	2、项目构建。实现项目的一步构建。
	3、工程聚合、继承、依赖。

  Maven的工程类型：
	1、war包工程（工程中必须要有一个war包）
	2、Jar包工程（jar包工程可以被其它工程所引用）
	3、Pom工程。（父工程或者聚合工程）
	
	注意：通常父类都是自己创建的项目，依赖是第三方的。父工程应该是一个pom工程。在父工程中定义依赖的jar包的版本信息和Maven插件的版本。
          在<dependencyManagement>标签中并不定义实际依赖，只是定义项目版本！
	
	
  后台管理系统工程结构：
		crm-parent -- 管理依赖jar包的版本，全局，公司级别
		|--crm-common  --- 通用组件、工具类
		|--crm-manager  -- 后台系统
		  |--com.crm.manage.web
		  |--com.crm.manage.service
		  |--com.crm.manage.mapper
		  |--com.crm.manage.pojo	
					
				
			
			
	如果要运行maven工程，最好是运行pom聚合工程！
	
	<build>
  	<plugins>
  		<plugin>
  			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<configuration>
				<port>8080</port>
				<path>/</path>
			</configuration>
  		</plugin>
  	</plugins>
  </build>
  
  当然运行项目的时候，可以使用上面的maven的tomcat插件(此tomcat是maven的，不是我们安装的那个tomcat)，只需要点击pom聚合工程的run as选择Maven build ...然后在
  出来的地方出现：输入clean tomcat7:run注意：这里是tomcat7哦，不是tomcat,如果运行的时候用的是tomcat:run那么这里的tomcat指的是tomcat6!
  
  
  tomcat服务器不支持从jar包中读取配置文件，所以我们的配置文件一般都是放在war包工程的resources配置文件中的！mybatis是支持从jar包中读取配置文件的！
  
  
  
  使用tomcat插件的时候，会有个小bug,当我们打断点调试的时候，当程序到达断点，但是当我们查看源码的时候，发现原本的源码找不到啦，我们只需要在弹出来的小
  图标中点击Edit Source Lookup Path;，然后再弹出的窗口中选择java project（这里不是选择project哦，而是java protect），然后找到对应的java项目，点击ok，然后重启项目就好！
  

  
  
  
  
  图片服务器两个服务：
	http：可以使用nginx做静态资源服务器。也可以使用apache。推荐使用nginx，效率更高。
	 Nginx：
	 1、http服务
	 2、反向代理
	 3、负载均衡

	ftp服务：
	 使用linux做服务器，在linux中有个ftp组件vsftpd。
  
  
  
  
  
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
